#include <bits/stdc++.h>
using namespace std;

class node{
    public:
    int parent;
    int rank;
};

class Edge{
    public:
      int v1;
      int v2;
      int w;

};


bool compare(Edge a, Edge b){
    return a.w<b.w;
}

int getParent(node* nodes, int v){

    if(nodes[v].parent!=v){
        nodes[v].parent=getParent(nodes,nodes[v].parent);
    }

    return nodes[v].parent;
}
void Union(node* nodes, int v1, int v2){

    int p1= getParent(nodes,v1);
    int p2= getParent(nodes,v2);

    if(nodes[p1].rank>nodes[p2].rank){
         nodes[p2].parent= p1;
    } else if(nodes[p2].rank> nodes[p1].rank){
         nodes[p1].parent=p2;
    } else{
         nodes[p2].parent=p1;
         nodes[p1].rank++;
    }

}
int main()
{
  int V, E, tempX, tempY;
  cin >> V >> E;

    Edge edges[E];
    Edge mst[V-1];

    for(int i=0;i<E;i++){
        cin>>edges[i].v1>>edges[i].v2>>edges[i].w;
    }

    sort(edges, edges+E, compare);


    node nodes[V];

    for(int i=0;i<V;i++){
        nodes[i].parent=i;
        nodes[i].rank=0;
    }

    int i=0;
    int count=0;

    while(count<V-1){

        int parOfV1= getParent(nodes, edges[i].v1);
        int parOfV2= getParent(nodes, edges[i].v2);
        if(parOfV1 == parOfV2){
            i++;
        }
        else{
            mst[count]=edges[i];
            Union(nodes,edges[i].v1,edges[i].v2);
            count++;
            i++;
        }
    

    }

    for(int i=0;i<V-1;i++){
        if(mst[i].v1<mst[i].v2){
            cout<<mst[i].v1<<" "<<mst[i].v2<<" "<<mst[i].w;
        }else{
            cout<<mst[i].v2<<" "<<mst[i].v1<<" "<<mst[i].w;
        }
        cout<<endl;
    }

  return 0;
}

